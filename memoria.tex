\documentclass[a4paper, 12pt, oneside]{book}
\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} 
\usepackage{url}
\usepackage{graphicx}
\usepackage{float} 
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{setspace}

\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\usepackage{listings}
\usepackage{color}
\usepackage{tcolorbox}
\tcbuselibrary{listingsutf8}

\title{Community Detection Algorithm}
\author{Michel Maes Bermejo}

\renewcommand{\baselinestretch}{1.5}

\begin{document}

\renewcommand{\refname}{Bibliografía} 
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA
\cleardoublepage
\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
\includegraphics[scale=0.6]{img/logos/urjc-logo.jpg} &
\end{tabular}

\vspace{1cm}

\Large
MASTER EN DATA SCIENCE

\vspace{0.4cm}

\large
Curso Académico 2018/2019

\vspace{0.8cm}

Trabajo Fin de Master

\vspace{2cm}

\LARGE
Divider Greedy algorithm for performing community detection in social networks

\vspace{2cm}

\large
Autor : Michel Maes Bermejo \\
Tutor : Jesús Sánchez-Oro Calvo

\end{center}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%
%%%% Resumen
%%%%%%%%%%%%%%%%%%%%

\chapter*{Resumen}
\pagenumbering{gobble}

\markboth{RESUMEN}{RESUMEN} % encabezado

En este proyecto abordaremos la creación de un algoritmo capaz de detectar comunidades en redes sociales, un problema en el que los algoritmos tradicionales no ofrecen soluciones rápidas. Para ello usaremos un enfoque metaheurístico basado en la división de comunidades e intentaremos mejorar sus prestaciones a lo largo de varias iteraciones.

%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       1.INTRODUCCIÓN Y MOTIVACIÓN           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción y motivación}
\label{sec:intro} 
\pagenumbering{arabic} 

Desde su nacimiento, Internet ha logrado conectar a las personas de forma sencilla. El ejemplo más claro son las redes sociales, que han crecido de forma contundente los últimos años. La rápidez con la que se transmite la información ha provocado que muchas personas las utilicen como medio de información de referencia frente a los tradicionales. Esto ha desencadenado un creciente interés de diferentes marcas e incluso de otros medios de aprovechar este fenómeno para su beneficio, aprovechando la estructura de red (o grafo) en la que se basa.

Desde el punto de vista de un científico de datos, resulta interesante estudiar la estructura que formas estas redes, que constituyen un ejemplo perfecto  de un grafo. Una de las áreas más interesantes que utiliza como base este tipo de redes es la detección de comunidades, que cuenta con multitud de aplicaciones.

Actualmente existen multitud de algoritmos que abordan el problema de la detección de comunidades. Los más tradicionales y exactos no son viables para abordar los grandes volumenes de datos que generan las redes sociales, por lo que se ha optado por soluciones heuristicas, no tan exactas, pero mucho más rápidas.

La motivación de este proyecto nace de la idea de crear una solución heurística diferente a las preexistentes (normalmente basadas en algun algun algoritmo destructivo), optando por un enfoque destructivo.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             2. Objetivos                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Objetivos}
\label{sec:objetivos} 

El objetivo principal de este proyecto será la creación de un algoritmo de detección de comunidades. Para ello utilizaremos un enfoque destructivo (comenzar con todos los nodos del grafo en la misma comunidad e ir haciendo particiones) contrario a un enfoque más utilizado, constructivo (comenzar con cada nodo en su propia comunidad e ir agrupandolos). Durante la construcción, usaremos la modularidad como métrica para evaluar nuestra solución. Realizaremos una serie de iteraciones en las cuales iremos mejorando el algoritmo con el fin de obtener la mejor versión del mismo.

Finalmente, compararemos nuestro algoritmo con otros preexistentes para valorar si es efectivo el enfoque elegido. En esta fase usaremos otras métricas sobre las particiones obtenidas como la conductancia o covertura.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 3. Tecnologías, Herramientas y Metodologías %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Tecnologías, Herramientas y Metodologías}
\label{sec:tecnologias} 

\section{Tecnologías}

\subsection{Java}
\label{subsec:java}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.04]{img/logos/java-logo.png}
	\caption{Logo Java}
	\label{figura:java}
\end{figure}

Java (Figura~\ref{figura:java}) es un lenguaje de programación de propósito general, concurrente y orientado a objetos. Su sintaxis deriva en gran medida de C y C++. Uno de los principales atractivos de Java es su máquina virtual (JVM) que nos permite ejecutar nuestro código Java en cualquier dispositivo, independientemente de la arquitectura.

\cleardoublepage
\section{Herramientas}

\subsection{Control de versiones: Git}
\label{subsec:git}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.08]{img/logos/git-logo.png}
	\caption{Logo Git}
	\label{figura:git}
\end{figure}


Git\footnote{\url{https://git-scm.com/}} (Figura~\ref{figura:git}) es un software de control de versiones diseñado por Linus Torvalds, pensando en la eficiencia y la confiabilidad del mantenimiento de versiones de aplicaciones cuando éstas tienen un gran número de archivos de código fuente.

\subsection{Entorno de desarrollo: IntelliJ}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.3]{img/logos/intellij-logo.png}
	\caption{Logo IntelliJ}
	\label{figura:intellij}
\end{figure}


IntelliJ\footnote{\url{https://www.jetbrains.com/idea/}} (Figura~\ref{figura:intellij}) es un IDE para Java desarollado por JetBrains ideado para mejorar la productividad del programador. 

\section{Metodologías}

Dado que pretendemos obtener la mejor versión de nuestro algoritmo, el desarrollo seguirá una metodología iterativa-incremental\footnote{\url{https://proyectosagiles.org/desarrollo-iterativo-incremental/}}, dónde en cada iteración se propondrán y evaluarán diferentes mejoras sobre el algoritmo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 		 4. Descripción informática           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Descripción informática}
\label{sec:descinformatica} 

En este apartado se abordará la construcción del proyecto. Este proyecto consta de una colección de algoritmos de detección de comunidades, que parte desde un algoritmo de detección aleatoria, pasando por la evolución de un algoritmo destructivo hasta obtener la mejor versión del mismo aplicando una búsqueda local.

\section{Requisitos}

\subsection{Requisitos funcionales}

Los requisitos funcionales de la aplicación son simples dado que se trata de un algoritmo:

\begin{itemize}
	\item Debe poder leer un fichero de entrada (correspondiente al grafo a tratar).
	\item Dado esa entrada y un algoritmo, debe devolver los clústers resultantes al realizar la detección de comunidades.  
\end{itemize}

\subsection{Requisitos no funcionales}

Los requisitos no funcionales de la aplicación se reducen a la calidad de la solución ofrecida y al tiempo de ejecución:

\begin{itemize}
	\item Maximizar la modularidad.
	\item Ofrecer el menor tiempo de cálculo posible\footnote{Existen algoritmos que ofrecen soluciones óptimas a este problema, pero no son aplicables a grafos grandes dado que requieren demasiado tiempo de computo.}. 
\end{itemize}

\begin{tcolorbox}[fonttitle=\bfseries,title=Modularidad,label=alg1]
	Las soluciones de los algoritmos de detección de comunidades se construyen máximizando su valor de modularidad, una medida utilizada para medir la fuerza de division de un grafo en clústers. Esta métrica se define cómo la fracción de enlaces que caen dentro de los clústers dados menos el valor esperado que dicha fracción hubiese recibido si los enlaces se hubiesen distribuido al azar. De forma matemática:
	
	\begin{equation*}
	Md(S,G) = \sum_{j=1}^{max(S)} (e_{jj} - a^{2}_{j})
	\end{equation*}
	
	dónde $S$ es la solución y $G$ el grafo, siendo $e_{jj}$ la fracción de enlaces con ambos vértices finales en el mismo grupo:
	
	\begin{equation*}
	e_{jj} = \frac{|\{(v,u) \epsilon E : S_{v} = S_{u} = j\}|}{|E|}
	\end{equation*}
	
	y $a_{j}$ la fracción de enlaces con al menos un extremo en la misma comunidad:
	
	\begin{equation*}
	a_{j} = \frac{|\{(v,u) \epsilon E : S_{v} = j\}|}{|E|}
	\end{equation*}
	siendo en ambos caso $E$ el conjunto de las aristas del grafo.
\end{tcolorbox}

\section{Diseño e implementación}

A continuación, se detallará la construcción incremental del algoritmo, explicando cada versión creada:

\begin{itemize}
	\item ConstRandom
	\item ConstDivider
	\item ConstDividerGreedy
	\item ConstDividerGreedyLS
\end{itemize}

\subsection{ConstRandom: Algoritmo aleatorio}

En esta primera aproximación que nos sirve como punto de partida y para posterior comparación, generamos los clústers de manera aleatoria; se crea un número aleatorio de clústers y se distribuyen los nodos de forma aleatorio en ellos.

\begin{spacing}{1}
	\begin{algorithm}
		\caption{ConsRandom algorithm}\label{euclid}
		\begin{algorithmic}[1]
			\Procedure{ConstRandom}{$g$}\Comment{The graph 'g'}
			\State $S \gets EmptySolution(G)$
			\State $numClusters \gets Random(N(g))$\Comment{N returns nº of graph nodes}
			
			\For{$i=0$ to $numClusters$}
				\State $createEmptyCluster(S)$
			\EndFor
			
			\For{$i=0$ to $N(S)$}
				\State $rnd \gets Random(numClusters)$
				\State $AssignToCluster(S, i, rnd)$ \Comment{Assign node $i$ to cluster $rnd$ in solution $S$}
			\EndFor
			
			\State \textbf{return} $S$
			
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
\end{spacing}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 		   5. Estudio comparativo             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estudio comparativo}
\label{sec:estudio} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 6. Conclusiones del proyecto y trabajos futuros %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones del proyecto y trabajos futuros}
\label{sec:conclusions} 

estigmérgicos~\cite{jya1}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

\bibliographystyle{abbrv}
\bibliography{memoria} 

\end{document}


